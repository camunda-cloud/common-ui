/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "./stencil-public-runtime";
import { Theme, ValidatorResult } from "./globalHelpers";
import { CmIconButton } from "./components/cm-icon-button/cm-icon-button";
import { DropdownOptionGroup } from "./components/cm-dropdown/cm-dropdown";
import { Entity, SortingDescription } from "./components/cm-entity-list/cm-entity-list";
import { DropdownOptionGroup as DropdownOptionGroup1 } from "./components/cm-dropdown/cm-dropdown";
import { CmIcon } from "./components/cm-icon/cm-icon";
import { NotificationItem } from "./components/cm-notification-container/cm-notification-container";
import { ComponentState } from "./components/cm-page/cm-page";
import { FieldPrefix, FieldSuffix, InputType } from "./components/cm-textfield/cm-textfield";
export namespace Components {
    interface CmBanner {
        "appearance": 'warning';
    }
    interface CmButton {
        "appearance": | 'main'
		| 'primary'
		| 'secondary'
		| 'danger'
		| 'link';
        "disabled": boolean;
        "label": string;
        /**
          * The loading state displays a spinner and effectively disables the button to user input. Does not affect buttons with the `link` appearance.
         */
        "loading": boolean;
        /**
          * Triggers the press event. Respects the disabled state unless forced.
         */
        "press": (options?: { forcePress?: boolean; }) => Promise<void>;
        "size": 'small' | 'normal';
    }
    interface CmCard {
        /**
          * Adds a Dismiss-Button to the Card, which fires the `cmDismissed` Event when pressed.
         */
        "isDismissable": boolean;
    }
    interface CmCheckbox {
        /**
          * Sets the checked state to true. Respects the disabled state, unless forced.
         */
        "check": (options?: { forceCheck?: boolean; triggeredBy?: 'User' | 'API'; }) => Promise<void>;
        "checkValidity": () => Promise<ValidatorResult>;
        "checked": boolean;
        "disabled": boolean;
        /**
          * Enables `cmInput` Events being emitted when the checked attribute changes.
         */
        "enableAttributeEmit": boolean;
        "forceFocus": () => Promise<void>;
        "formName": string;
        "helperText": string;
        "hideValidity": () => Promise<void>;
        "indeterminate": boolean;
        "label": string;
        "renderValidity": () => Promise<void>;
        "required": boolean;
        "reset": () => Promise<void>;
        /**
          * Toggles the checked state. Respects the disabled state, unless forced.
         */
        "toggleCheck": (options?: { forceToggle?: boolean; triggeredBy?: 'User' | 'API'; }) => Promise<void>;
        /**
          * Sets the checked state to false. Respects the disabled state, unless forced.
         */
        "uncheck": (options?: { forceUncheck?: boolean; triggeredBy?: 'User' | 'API'; }) => Promise<void>;
    }
    interface CmCheckboxGroup {
        "label": string;
    }
    interface CmContext {
        /**
          * Returns the actual theme, resolving "Automatic" to an actual value.
         */
        "getResolvedTheme": () => Promise<Theme>;
        /**
          * Returns the Value of the requested variable, caching it in the process.
         */
        "getVariableValue": (name: string) => Promise<string>;
        "theme": Theme | 'Automatic';
    }
    interface CmDatalist {
        "headline": string;
        /**
          * Sets the width of the label for all cm-datalist-item's inside this cm-datalist. Expected format is a valid CSS Grid Column value.
         */
        "labelWidth": string;
    }
    interface CmDatalistItem {
        "label": string;
        "labelWidth": string;
    }
    interface CmDropdown {
        /**
          * Closes the Dropdown.
         */
        "close": () => Promise<void>;
        /**
          * Opens the Dropdown.
         */
        "open": () => Promise<void>;
        "options": Array<DropdownOptionGroup>;
        "trigger": | { type: 'icon'; icon: CmIconButton['icon'] }
		| {
				type: 'button'
				label: string
				appearance: 'main' | 'primary' | 'secondary'
		  }
		| {
				type: 'defaultAction'
				label: string
				appearance: 'main' | 'primary' | 'secondary'
				defaultHandler: () => void
		  }
		| { type: 'label'; label: string };
        /**
          * Triggers an option, as if selected by the user. The Dropdown is _not_ required to be open for this to work.
         */
        "triggerOptionByIndex": (optionGroupIndex: number, optionIndex: number) => Promise<void>;
    }
    interface CmEntityList {
        "addScrollPadding"?: boolean;
        "columns": Array<{
		name: string
		width: string
		ellipsis?: 'off' | 'left' | 'right'
		overrideCSS?: Record<string, string>
	}>;
        "createButtonLabel": string;
        "createHandler": () => void;
        "defaultSorting"?: SortingDescription;
        /**
          * De-selects all entities.
         */
        "deselectAll": () => Promise<void>;
        /**
          * De-selects the entity at the given index. Note that the index is based of the entity array and ignores all sorting.
         */
        "deselectIndex": (index: number) => Promise<void>;
        "enableCreateButton": boolean;
        "entities": Array<Entity>;
        "groupOptions": Array<DropdownOptionGroup>;
        "headline": string;
        "loading": boolean;
        /**
          * Selects all entities.
         */
        "selectAll": () => Promise<void>;
        /**
          * Selects the entity at the given index. Note that the index is based of the entity array and ignores all sorting.
         */
        "selectIndex": (index: number) => Promise<void>;
        /**
          * Triggers an option of entity at the given index as if selected by the user, if available. Note that the entity index is based of the entity array and ignores all sorting.
         */
        "triggerEntityOption": (options: { entityIndex: number; optionGroupIndex: number; optionIndex: number; }) => Promise<void>;
        /**
          * Triggers an option of the group-actions-dropdown as if selected by the user, if available. Needs selected entities to function.
         */
        "triggerGroupOption": (optionGroupIndex: number, optionIndex: number) => Promise<void>;
    }
    interface CmFilter {
        /**
          * The Index of the active filter.
         */
        "activeFilterIndex": number;
        "filters": Array<{
		label: string
		value: string
		title?: string
		disabled?: boolean
	}>;
    }
    interface CmFooter {
        "text": string;
    }
    interface CmForm {
        "attemptSubmit": () => Promise<{ isValid: true; data: Record<string, string>; } | { isValid: false; }>;
        "forceFocus": () => Promise<void>;
        "reset": () => Promise<void>;
    }
    interface CmFormGroup {
        "label": string;
    }
    interface CmHeader {
    }
    interface CmIcon {
        "color": | 'bright'
		| 'medium'
		| 'dark'
		| 'success'
		| 'warning'
		| 'danger';
        "icon": | 'check'
		| 'close'
		| 'closeLarge'
		| 'contextMenu'
		| 'copy'
		| 'delete'
		| 'document'
		| 'down'
		| 'edit'
		| 'email'
		| 'external'
		| 'help'
		| 'hide'
		| 'information'
		| 'left'
		| 'minus'
		| 'plus'
		| 'right'
		| 'search'
		| 'show'
		| 'sort'
		| 'stop'
		| 'up'
		| 'warning';
        "ignoreTheme": boolean;
    }
    interface CmIconButton {
        "color": CmIcon['color'];
        "disabled": boolean;
        "icon": CmIcon['icon'];
        "ignoreTheme": boolean;
        /**
          * Triggers the press event. Respects the disabled state unless forced.
         */
        "press": (options?: { forcePress?: boolean; }) => Promise<void>;
    }
    interface CmLink {
        "href": string;
        "label": string;
        "openIn": 'sameTab' | 'newTab';
    }
    interface CmLoader {
        "color": 'dark' | 'light';
        "size": 'small' | 'normal';
    }
    interface CmLogo {
    }
    interface CmModal {
        /**
          * Triggers the 'cancel' action on the modal, if it is open.
         */
        "cancel": () => Promise<{ result: "confirm"; formData?: Record<string, string>; } | { result: "cancel"; }>;
        "cancelAppearance": 'secondary' | 'danger';
        "cancelLabel": string;
        /**
          * Triggers the 'confirm' action on the modal, if it is open.
         */
        "confirm": () => Promise<{ result: "confirm"; formData?: Record<string, string>; } | { result: "cancel"; }>;
        "confirmAppearance": | 'primary'
		| 'danger'
		| 'secondary';
        "confirmDisabled": boolean;
        "confirmLabel": string;
        "headline": string;
        /**
          * Opens the modal. Takes an optional handler for asynchronous confirm actions, which only trigger confirm if the returned Promise resolves successfully. While the Promise is unresolved, the Modal stays open and the ConfirmButton is in a loading state.
         */
        "open": (options?: { preConfirmationHandler?: () => Promise<void>; preventFormReset?: boolean; }) => Promise<{ result: "confirm"; formData?: Record<string, string>; } | { result: "cancel"; }>;
        "paddings": | 'all'
		| 'vertical'
		| 'horizontal'
		| 'none';
        "position": 'top' | 'center';
        "width": number;
    }
    interface CmNotification {
        "appearance": 'success' | 'error' | 'info';
        "createdAt": number;
        "description": string;
        /**
          * Dismisses the Notification.
         */
        "dismiss": () => Promise<void>;
        "headline": string;
        /**
          * Returns the hover state. This is being used to halt Notification-Timeouts.
         */
        "isBeingHovered": () => Promise<boolean>;
        "navigationLabel": string;
        "showCreationTime": boolean;
        "userDismissable": boolean;
    }
    interface CmNotificationContainer {
        /**
          * Queues a Notification to be shown. The notification might be shown instantly, if there is space, or later, once space is available.
         */
        "enqueueNotification": (notification: Omit<NotificationItem, 'createdAt'>) => Promise<{ hasBeenShown(): boolean; remove(): void; }>;
    }
    interface CmPage {
        "activeLabel": string;
        /**
          * Returns the currently active tab, handle, and title.
         */
        "getActiveState": () => Promise<ComponentState>;
        /**
          * Switches to a tab based on their label.
          * @param label Title of the target tab.
         */
        "switchToTab": (label: string) => Promise<void>;
        /**
          * Switches to a tab based on their index.
          * @param index Index of the target tab.
         */
        "switchToTabIndex": (index: number) => Promise<void>;
    }
    interface CmPageTab {
        "active": boolean;
        "label": string;
    }
    interface CmPageTabHandle {
        "active": boolean;
        "label": string;
    }
    interface CmRadiobutton {
        "disabled": boolean;
        "helperText": string;
        "label": string;
        /**
          * Sets the selected state to true. Respects the disabled state, unless forced.
         */
        "select": (options?: { forceSelection?: boolean; triggeredBy?: 'User' | 'API'; }) => Promise<void>;
        "selected": boolean;
        "value": string;
    }
    interface CmRadiobuttonGroup {
        "formName": string;
        "label": string;
        "value": string;
    }
    interface CmSelect {
        "disabled": boolean;
        "options": Array<{
		label: string
		value: string
	}>;
        /**
          * Selects an option based on the passed index. Respects the disabled state unless forced.
         */
        "selectOptionByIndex": (options: { forceSelection?: boolean; selectedIndex: number; }) => Promise<void>;
    }
    interface CmText {
        "appearance": | 'normal'
		| 'emphasis'
		| 'helperText'
		| 'entityListItem'
		| 'entityListName';
        "color": 'bright' | 'subtle';
    }
    interface CmTextfield {
        "autocomplete": HTMLInputElement['autocomplete'];
        "checkValidity": () => Promise<ValidatorResult>;
        "disabled": boolean;
        "fieldPrefix": FieldPrefix;
        "fieldSuffix": FieldSuffix;
        "forceFocus": () => Promise<void>;
        "formName": string;
        "helperText": string;
        "hideValidity": () => Promise<void>;
        "label": string;
        "labelAlignment": | 'horizontal'
		| 'vertical';
        "maxLength": | number
		| undefined;
        "placeholder": string;
        "renderValidity": () => Promise<void>;
        "required": boolean;
        "reset": () => Promise<void>;
        "showRequired": boolean;
        "type": InputType;
        "validation": | { type: 'default' }
		| {
				type: 'custom'
				validator: (value: string) => Promise<ValidatorResult>
		  };
        "validationStyle": | 'form'
		| 'live'
		| 'delay';
        "value": string;
    }
    interface CmToggle {
        /**
          * Sets the checked state to true. Respects the disabled state, unless forced.
         */
        "check": (options?: { forceCheck?: boolean; triggeredBy?: 'User' | 'API'; }) => Promise<void>;
        "checked": boolean;
        "disabled": boolean;
        /**
          * Enables `cmInput` Events being emitted when the checked attribute changes.
         */
        "enableAttributeEmit": boolean;
        "label": string;
        /**
          * Toggles the checked state. Respects the disabled state, unless forced.
         */
        "toggleCheck": (options?: { forceToggle?: boolean; triggeredBy?: 'User' | 'API'; }) => Promise<void>;
        /**
          * Sets the checked state to false. Respects the disabled state, unless forced.
         */
        "uncheck": (options?: { forceUncheck?: boolean; triggeredBy?: 'User' | 'API'; }) => Promise<void>;
    }
}
declare global {
    interface HTMLCmBannerElement extends Components.CmBanner, HTMLStencilElement {
    }
    var HTMLCmBannerElement: {
        prototype: HTMLCmBannerElement;
        new (): HTMLCmBannerElement;
    };
    interface HTMLCmButtonElement extends Components.CmButton, HTMLStencilElement {
    }
    var HTMLCmButtonElement: {
        prototype: HTMLCmButtonElement;
        new (): HTMLCmButtonElement;
    };
    interface HTMLCmCardElement extends Components.CmCard, HTMLStencilElement {
    }
    var HTMLCmCardElement: {
        prototype: HTMLCmCardElement;
        new (): HTMLCmCardElement;
    };
    interface HTMLCmCheckboxElement extends Components.CmCheckbox, HTMLStencilElement {
    }
    var HTMLCmCheckboxElement: {
        prototype: HTMLCmCheckboxElement;
        new (): HTMLCmCheckboxElement;
    };
    interface HTMLCmCheckboxGroupElement extends Components.CmCheckboxGroup, HTMLStencilElement {
    }
    var HTMLCmCheckboxGroupElement: {
        prototype: HTMLCmCheckboxGroupElement;
        new (): HTMLCmCheckboxGroupElement;
    };
    interface HTMLCmContextElement extends Components.CmContext, HTMLStencilElement {
    }
    var HTMLCmContextElement: {
        prototype: HTMLCmContextElement;
        new (): HTMLCmContextElement;
    };
    interface HTMLCmDatalistElement extends Components.CmDatalist, HTMLStencilElement {
    }
    var HTMLCmDatalistElement: {
        prototype: HTMLCmDatalistElement;
        new (): HTMLCmDatalistElement;
    };
    interface HTMLCmDatalistItemElement extends Components.CmDatalistItem, HTMLStencilElement {
    }
    var HTMLCmDatalistItemElement: {
        prototype: HTMLCmDatalistItemElement;
        new (): HTMLCmDatalistItemElement;
    };
    interface HTMLCmDropdownElement extends Components.CmDropdown, HTMLStencilElement {
    }
    var HTMLCmDropdownElement: {
        prototype: HTMLCmDropdownElement;
        new (): HTMLCmDropdownElement;
    };
    interface HTMLCmEntityListElement extends Components.CmEntityList, HTMLStencilElement {
    }
    var HTMLCmEntityListElement: {
        prototype: HTMLCmEntityListElement;
        new (): HTMLCmEntityListElement;
    };
    interface HTMLCmFilterElement extends Components.CmFilter, HTMLStencilElement {
    }
    var HTMLCmFilterElement: {
        prototype: HTMLCmFilterElement;
        new (): HTMLCmFilterElement;
    };
    interface HTMLCmFooterElement extends Components.CmFooter, HTMLStencilElement {
    }
    var HTMLCmFooterElement: {
        prototype: HTMLCmFooterElement;
        new (): HTMLCmFooterElement;
    };
    interface HTMLCmFormElement extends Components.CmForm, HTMLStencilElement {
    }
    var HTMLCmFormElement: {
        prototype: HTMLCmFormElement;
        new (): HTMLCmFormElement;
    };
    interface HTMLCmFormGroupElement extends Components.CmFormGroup, HTMLStencilElement {
    }
    var HTMLCmFormGroupElement: {
        prototype: HTMLCmFormGroupElement;
        new (): HTMLCmFormGroupElement;
    };
    interface HTMLCmHeaderElement extends Components.CmHeader, HTMLStencilElement {
    }
    var HTMLCmHeaderElement: {
        prototype: HTMLCmHeaderElement;
        new (): HTMLCmHeaderElement;
    };
    interface HTMLCmIconElement extends Components.CmIcon, HTMLStencilElement {
    }
    var HTMLCmIconElement: {
        prototype: HTMLCmIconElement;
        new (): HTMLCmIconElement;
    };
    interface HTMLCmIconButtonElement extends Components.CmIconButton, HTMLStencilElement {
    }
    var HTMLCmIconButtonElement: {
        prototype: HTMLCmIconButtonElement;
        new (): HTMLCmIconButtonElement;
    };
    interface HTMLCmLinkElement extends Components.CmLink, HTMLStencilElement {
    }
    var HTMLCmLinkElement: {
        prototype: HTMLCmLinkElement;
        new (): HTMLCmLinkElement;
    };
    interface HTMLCmLoaderElement extends Components.CmLoader, HTMLStencilElement {
    }
    var HTMLCmLoaderElement: {
        prototype: HTMLCmLoaderElement;
        new (): HTMLCmLoaderElement;
    };
    interface HTMLCmLogoElement extends Components.CmLogo, HTMLStencilElement {
    }
    var HTMLCmLogoElement: {
        prototype: HTMLCmLogoElement;
        new (): HTMLCmLogoElement;
    };
    interface HTMLCmModalElement extends Components.CmModal, HTMLStencilElement {
    }
    var HTMLCmModalElement: {
        prototype: HTMLCmModalElement;
        new (): HTMLCmModalElement;
    };
    interface HTMLCmNotificationElement extends Components.CmNotification, HTMLStencilElement {
    }
    var HTMLCmNotificationElement: {
        prototype: HTMLCmNotificationElement;
        new (): HTMLCmNotificationElement;
    };
    interface HTMLCmNotificationContainerElement extends Components.CmNotificationContainer, HTMLStencilElement {
    }
    var HTMLCmNotificationContainerElement: {
        prototype: HTMLCmNotificationContainerElement;
        new (): HTMLCmNotificationContainerElement;
    };
    interface HTMLCmPageElement extends Components.CmPage, HTMLStencilElement {
    }
    var HTMLCmPageElement: {
        prototype: HTMLCmPageElement;
        new (): HTMLCmPageElement;
    };
    interface HTMLCmPageTabElement extends Components.CmPageTab, HTMLStencilElement {
    }
    var HTMLCmPageTabElement: {
        prototype: HTMLCmPageTabElement;
        new (): HTMLCmPageTabElement;
    };
    interface HTMLCmPageTabHandleElement extends Components.CmPageTabHandle, HTMLStencilElement {
    }
    var HTMLCmPageTabHandleElement: {
        prototype: HTMLCmPageTabHandleElement;
        new (): HTMLCmPageTabHandleElement;
    };
    interface HTMLCmRadiobuttonElement extends Components.CmRadiobutton, HTMLStencilElement {
    }
    var HTMLCmRadiobuttonElement: {
        prototype: HTMLCmRadiobuttonElement;
        new (): HTMLCmRadiobuttonElement;
    };
    interface HTMLCmRadiobuttonGroupElement extends Components.CmRadiobuttonGroup, HTMLStencilElement {
    }
    var HTMLCmRadiobuttonGroupElement: {
        prototype: HTMLCmRadiobuttonGroupElement;
        new (): HTMLCmRadiobuttonGroupElement;
    };
    interface HTMLCmSelectElement extends Components.CmSelect, HTMLStencilElement {
    }
    var HTMLCmSelectElement: {
        prototype: HTMLCmSelectElement;
        new (): HTMLCmSelectElement;
    };
    interface HTMLCmTextElement extends Components.CmText, HTMLStencilElement {
    }
    var HTMLCmTextElement: {
        prototype: HTMLCmTextElement;
        new (): HTMLCmTextElement;
    };
    interface HTMLCmTextfieldElement extends Components.CmTextfield, HTMLStencilElement {
    }
    var HTMLCmTextfieldElement: {
        prototype: HTMLCmTextfieldElement;
        new (): HTMLCmTextfieldElement;
    };
    interface HTMLCmToggleElement extends Components.CmToggle, HTMLStencilElement {
    }
    var HTMLCmToggleElement: {
        prototype: HTMLCmToggleElement;
        new (): HTMLCmToggleElement;
    };
    interface HTMLElementTagNameMap {
        "cm-banner": HTMLCmBannerElement;
        "cm-button": HTMLCmButtonElement;
        "cm-card": HTMLCmCardElement;
        "cm-checkbox": HTMLCmCheckboxElement;
        "cm-checkbox-group": HTMLCmCheckboxGroupElement;
        "cm-context": HTMLCmContextElement;
        "cm-datalist": HTMLCmDatalistElement;
        "cm-datalist-item": HTMLCmDatalistItemElement;
        "cm-dropdown": HTMLCmDropdownElement;
        "cm-entity-list": HTMLCmEntityListElement;
        "cm-filter": HTMLCmFilterElement;
        "cm-footer": HTMLCmFooterElement;
        "cm-form": HTMLCmFormElement;
        "cm-form-group": HTMLCmFormGroupElement;
        "cm-header": HTMLCmHeaderElement;
        "cm-icon": HTMLCmIconElement;
        "cm-icon-button": HTMLCmIconButtonElement;
        "cm-link": HTMLCmLinkElement;
        "cm-loader": HTMLCmLoaderElement;
        "cm-logo": HTMLCmLogoElement;
        "cm-modal": HTMLCmModalElement;
        "cm-notification": HTMLCmNotificationElement;
        "cm-notification-container": HTMLCmNotificationContainerElement;
        "cm-page": HTMLCmPageElement;
        "cm-page-tab": HTMLCmPageTabElement;
        "cm-page-tab-handle": HTMLCmPageTabHandleElement;
        "cm-radiobutton": HTMLCmRadiobuttonElement;
        "cm-radiobutton-group": HTMLCmRadiobuttonGroupElement;
        "cm-select": HTMLCmSelectElement;
        "cm-text": HTMLCmTextElement;
        "cm-textfield": HTMLCmTextfieldElement;
        "cm-toggle": HTMLCmToggleElement;
    }
}
declare namespace LocalJSX {
    interface CmBanner {
        "appearance"?: 'warning';
    }
    interface CmButton {
        "appearance"?: | 'main'
		| 'primary'
		| 'secondary'
		| 'danger'
		| 'link';
        "disabled"?: boolean;
        "label"?: string;
        /**
          * The loading state displays a spinner and effectively disables the button to user input. Does not affect buttons with the `link` appearance.
         */
        "loading"?: boolean;
        /**
          * Emitted when the button is pressed or either Spacebar or Enter are being pressed when the button is focused.
         */
        "onCmPress"?: (event: CustomEvent<{}>) => void;
        "size"?: 'small' | 'normal';
    }
    interface CmCard {
        /**
          * Adds a Dismiss-Button to the Card, which fires the `cmDismissed` Event when pressed.
         */
        "isDismissable"?: boolean;
        /**
          * Emitted when the Card is being dismissed. Has no default action.
         */
        "onCmDismissed"?: (event: CustomEvent<{}>) => void;
    }
    interface CmCheckbox {
        "checked"?: boolean;
        "disabled"?: boolean;
        /**
          * Enables `cmInput` Events being emitted when the checked attribute changes.
         */
        "enableAttributeEmit"?: boolean;
        "formName"?: string;
        "helperText"?: string;
        "indeterminate"?: boolean;
        "label"?: string;
        /**
          * Emitted whenever the checked state changes.
         */
        "onCmInput"?: (event: CustomEvent<{
		isChecked: boolean
		triggeredBy: 'User' | 'API'
	}>) => void;
        "required"?: boolean;
    }
    interface CmCheckboxGroup {
        "label"?: string;
    }
    interface CmContext {
        /**
          * Emitted when the resolved theme changes.
         */
        "onThemeChanged"?: (event: CustomEvent<{ theme: Theme }>) => void;
        "theme"?: Theme | 'Automatic';
    }
    interface CmDatalist {
        "headline"?: string;
        /**
          * Sets the width of the label for all cm-datalist-item's inside this cm-datalist. Expected format is a valid CSS Grid Column value.
         */
        "labelWidth"?: string;
    }
    interface CmDatalistItem {
        "label"?: string;
        "labelWidth"?: string;
    }
    interface CmDropdown {
        "options"?: Array<DropdownOptionGroup>;
        "trigger"?: | { type: 'icon'; icon: CmIconButton['icon'] }
		| {
				type: 'button'
				label: string
				appearance: 'main' | 'primary' | 'secondary'
		  }
		| {
				type: 'defaultAction'
				label: string
				appearance: 'main' | 'primary' | 'secondary'
				defaultHandler: () => void
		  }
		| { type: 'label'; label: string };
    }
    interface CmEntityList {
        "addScrollPadding"?: boolean;
        "columns"?: Array<{
		name: string
		width: string
		ellipsis?: 'off' | 'left' | 'right'
		overrideCSS?: Record<string, string>
	}>;
        "createButtonLabel"?: string;
        "createHandler"?: () => void;
        "defaultSorting"?: SortingDescription;
        "enableCreateButton"?: boolean;
        "entities"?: Array<Entity>;
        "groupOptions"?: Array<DropdownOptionGroup>;
        "headline"?: string;
        "loading"?: boolean;
    }
    interface CmFilter {
        /**
          * The Index of the active filter.
         */
        "activeFilterIndex"?: number;
        "filters"?: Array<{
		label: string
		value: string
		title?: string
		disabled?: boolean
	}>;
        /**
          * Emitted whenever the selected filter changes.
         */
        "onCmFilterSelected"?: (event: CustomEvent<{ value: string }>) => void;
    }
    interface CmFooter {
        "text"?: string;
    }
    interface CmForm {
        "onCmSubmit"?: (event: CustomEvent<{ data: Record<string, string> }>) => void;
    }
    interface CmFormGroup {
        "label"?: string;
    }
    interface CmHeader {
    }
    interface CmIcon {
        "color"?: | 'bright'
		| 'medium'
		| 'dark'
		| 'success'
		| 'warning'
		| 'danger';
        "icon"?: | 'check'
		| 'close'
		| 'closeLarge'
		| 'contextMenu'
		| 'copy'
		| 'delete'
		| 'document'
		| 'down'
		| 'edit'
		| 'email'
		| 'external'
		| 'help'
		| 'hide'
		| 'information'
		| 'left'
		| 'minus'
		| 'plus'
		| 'right'
		| 'search'
		| 'show'
		| 'sort'
		| 'stop'
		| 'up'
		| 'warning';
        "ignoreTheme"?: boolean;
    }
    interface CmIconButton {
        "color"?: CmIcon['color'];
        "disabled"?: boolean;
        "icon"?: CmIcon['icon'];
        "ignoreTheme"?: boolean;
        /**
          * Emitted when the button is pressed or either Spacebar or Enter are being pressed when the button is focused.
         */
        "onCmPress"?: (event: CustomEvent<{}>) => void;
    }
    interface CmLink {
        "href"?: string;
        "label"?: string;
        "openIn"?: 'sameTab' | 'newTab';
    }
    interface CmLoader {
        "color"?: 'dark' | 'light';
        "size"?: 'small' | 'normal';
    }
    interface CmLogo {
    }
    interface CmModal {
        "cancelAppearance"?: 'secondary' | 'danger';
        "cancelLabel"?: string;
        "confirmAppearance"?: | 'primary'
		| 'danger'
		| 'secondary';
        "confirmDisabled"?: boolean;
        "confirmLabel"?: string;
        "headline"?: string;
        "paddings"?: | 'all'
		| 'vertical'
		| 'horizontal'
		| 'none';
        "position"?: 'top' | 'center';
        "width"?: number;
    }
    interface CmNotification {
        "appearance"?: 'success' | 'error' | 'info';
        "createdAt"?: number;
        "description"?: string;
        "headline"?: string;
        "navigationLabel"?: string;
        /**
          * Emitted when the Notification is dismissed.
         */
        "onCmDismissed"?: (event: CustomEvent<{}>) => void;
        /**
          * Emitted when the Navigation is triggered.
         */
        "onCmNotificationNavigation"?: (event: CustomEvent<{}>) => void;
        /**
          * Emitted when Component has loaded, used as a workaround for the lack of a general 'componentDidLoad' event internally. You should not rely on this event.
         */
        "onDidLoad"?: (event: CustomEvent<{}>) => void;
        "showCreationTime"?: boolean;
        "userDismissable"?: boolean;
    }
    interface CmNotificationContainer {
    }
    interface CmPage {
        "activeLabel"?: string;
        /**
          * This is emitted when the active tab is changed.
         */
        "onTabChanged"?: (event: CustomEvent<ComponentState>) => void;
    }
    interface CmPageTab {
        "active"?: boolean;
        "label"?: string;
        /**
          * Emitted when the Tab is modified, e.g. when the label is changed.
         */
        "onTabModified"?: (event: CustomEvent<any>) => void;
    }
    interface CmPageTabHandle {
        "active"?: boolean;
        "label"?: string;
        /**
          * Emitted when the Tab is being selected by the user.
         */
        "onUserSelectedTab"?: (event: CustomEvent<{
		originalEvent: MouseEvent | KeyboardEvent
		handle: HTMLCmPageTabHandleElement
		label: string
	}>) => void;
    }
    interface CmRadiobutton {
        "disabled"?: boolean;
        "helperText"?: string;
        "label"?: string;
        /**
          * Emitted whenever the selected state changes.
         */
        "onCmSelected"?: (event: CustomEvent<{
		value: string
		triggeredBy: 'User' | 'API'
	}>) => void;
        "selected"?: boolean;
        "value"?: string;
    }
    interface CmRadiobuttonGroup {
        "formName"?: string;
        "label"?: string;
        "value"?: string;
    }
    interface CmSelect {
        "disabled"?: boolean;
        /**
          * Emitted when the selected Option changes.
         */
        "onCmInput"?: (event: CustomEvent<{ newValue: string }>) => void;
        "options"?: Array<{
		label: string
		value: string
	}>;
    }
    interface CmText {
        "appearance"?: | 'normal'
		| 'emphasis'
		| 'helperText'
		| 'entityListItem'
		| 'entityListName';
        "color"?: 'bright' | 'subtle';
    }
    interface CmTextfield {
        "autocomplete"?: HTMLInputElement['autocomplete'];
        "disabled"?: boolean;
        "fieldPrefix"?: FieldPrefix;
        "fieldSuffix"?: FieldSuffix;
        "formName"?: string;
        "helperText"?: string;
        "label"?: string;
        "labelAlignment"?: | 'horizontal'
		| 'vertical';
        "maxLength"?: | number
		| undefined;
        "placeholder"?: string;
        "required"?: boolean;
        "showRequired"?: boolean;
        "type"?: InputType;
        "validation"?: | { type: 'default' }
		| {
				type: 'custom'
				validator: (value: string) => Promise<ValidatorResult>
		  };
        "validationStyle"?: | 'form'
		| 'live'
		| 'delay';
        "value"?: string;
    }
    interface CmToggle {
        "checked"?: boolean;
        "disabled"?: boolean;
        /**
          * Enables `cmInput` Events being emitted when the checked attribute changes.
         */
        "enableAttributeEmit"?: boolean;
        "label"?: string;
        /**
          * Emitted whenever the checked state changes.
         */
        "onCmInput"?: (event: CustomEvent<{
		isChecked: boolean
		triggeredBy: 'User' | 'API'
	}>) => void;
    }
    interface IntrinsicElements {
        "cm-banner": CmBanner;
        "cm-button": CmButton;
        "cm-card": CmCard;
        "cm-checkbox": CmCheckbox;
        "cm-checkbox-group": CmCheckboxGroup;
        "cm-context": CmContext;
        "cm-datalist": CmDatalist;
        "cm-datalist-item": CmDatalistItem;
        "cm-dropdown": CmDropdown;
        "cm-entity-list": CmEntityList;
        "cm-filter": CmFilter;
        "cm-footer": CmFooter;
        "cm-form": CmForm;
        "cm-form-group": CmFormGroup;
        "cm-header": CmHeader;
        "cm-icon": CmIcon;
        "cm-icon-button": CmIconButton;
        "cm-link": CmLink;
        "cm-loader": CmLoader;
        "cm-logo": CmLogo;
        "cm-modal": CmModal;
        "cm-notification": CmNotification;
        "cm-notification-container": CmNotificationContainer;
        "cm-page": CmPage;
        "cm-page-tab": CmPageTab;
        "cm-page-tab-handle": CmPageTabHandle;
        "cm-radiobutton": CmRadiobutton;
        "cm-radiobutton-group": CmRadiobuttonGroup;
        "cm-select": CmSelect;
        "cm-text": CmText;
        "cm-textfield": CmTextfield;
        "cm-toggle": CmToggle;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "cm-banner": LocalJSX.CmBanner & JSXBase.HTMLAttributes<HTMLCmBannerElement>;
            "cm-button": LocalJSX.CmButton & JSXBase.HTMLAttributes<HTMLCmButtonElement>;
            "cm-card": LocalJSX.CmCard & JSXBase.HTMLAttributes<HTMLCmCardElement>;
            "cm-checkbox": LocalJSX.CmCheckbox & JSXBase.HTMLAttributes<HTMLCmCheckboxElement>;
            "cm-checkbox-group": LocalJSX.CmCheckboxGroup & JSXBase.HTMLAttributes<HTMLCmCheckboxGroupElement>;
            "cm-context": LocalJSX.CmContext & JSXBase.HTMLAttributes<HTMLCmContextElement>;
            "cm-datalist": LocalJSX.CmDatalist & JSXBase.HTMLAttributes<HTMLCmDatalistElement>;
            "cm-datalist-item": LocalJSX.CmDatalistItem & JSXBase.HTMLAttributes<HTMLCmDatalistItemElement>;
            "cm-dropdown": LocalJSX.CmDropdown & JSXBase.HTMLAttributes<HTMLCmDropdownElement>;
            "cm-entity-list": LocalJSX.CmEntityList & JSXBase.HTMLAttributes<HTMLCmEntityListElement>;
            "cm-filter": LocalJSX.CmFilter & JSXBase.HTMLAttributes<HTMLCmFilterElement>;
            "cm-footer": LocalJSX.CmFooter & JSXBase.HTMLAttributes<HTMLCmFooterElement>;
            "cm-form": LocalJSX.CmForm & JSXBase.HTMLAttributes<HTMLCmFormElement>;
            "cm-form-group": LocalJSX.CmFormGroup & JSXBase.HTMLAttributes<HTMLCmFormGroupElement>;
            "cm-header": LocalJSX.CmHeader & JSXBase.HTMLAttributes<HTMLCmHeaderElement>;
            "cm-icon": LocalJSX.CmIcon & JSXBase.HTMLAttributes<HTMLCmIconElement>;
            "cm-icon-button": LocalJSX.CmIconButton & JSXBase.HTMLAttributes<HTMLCmIconButtonElement>;
            "cm-link": LocalJSX.CmLink & JSXBase.HTMLAttributes<HTMLCmLinkElement>;
            "cm-loader": LocalJSX.CmLoader & JSXBase.HTMLAttributes<HTMLCmLoaderElement>;
            "cm-logo": LocalJSX.CmLogo & JSXBase.HTMLAttributes<HTMLCmLogoElement>;
            "cm-modal": LocalJSX.CmModal & JSXBase.HTMLAttributes<HTMLCmModalElement>;
            "cm-notification": LocalJSX.CmNotification & JSXBase.HTMLAttributes<HTMLCmNotificationElement>;
            "cm-notification-container": LocalJSX.CmNotificationContainer & JSXBase.HTMLAttributes<HTMLCmNotificationContainerElement>;
            "cm-page": LocalJSX.CmPage & JSXBase.HTMLAttributes<HTMLCmPageElement>;
            "cm-page-tab": LocalJSX.CmPageTab & JSXBase.HTMLAttributes<HTMLCmPageTabElement>;
            "cm-page-tab-handle": LocalJSX.CmPageTabHandle & JSXBase.HTMLAttributes<HTMLCmPageTabHandleElement>;
            "cm-radiobutton": LocalJSX.CmRadiobutton & JSXBase.HTMLAttributes<HTMLCmRadiobuttonElement>;
            "cm-radiobutton-group": LocalJSX.CmRadiobuttonGroup & JSXBase.HTMLAttributes<HTMLCmRadiobuttonGroupElement>;
            "cm-select": LocalJSX.CmSelect & JSXBase.HTMLAttributes<HTMLCmSelectElement>;
            "cm-text": LocalJSX.CmText & JSXBase.HTMLAttributes<HTMLCmTextElement>;
            "cm-textfield": LocalJSX.CmTextfield & JSXBase.HTMLAttributes<HTMLCmTextfieldElement>;
            "cm-toggle": LocalJSX.CmToggle & JSXBase.HTMLAttributes<HTMLCmToggleElement>;
        }
    }
}
